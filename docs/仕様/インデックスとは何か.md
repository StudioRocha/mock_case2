# インデックスとは何か

## 概要

「カラムにインデックスを張る」とは、データベースの検索を高速化するための仕組みです。本ドキュメントでは、インデックスの仕組みと効果をわかりやすく説明します。

---

## インデックスとは

### 簡単に言うと

**インデックス = 本の索引（さくいん）**

本の最後にある索引のように、データベースでも「どのデータがどこにあるか」を素早く見つけるための目次を作成します。

### 具体例：電話帳の例

#### インデックスがない場合（全件スキャン）

```
電話帳（50音順に並んでいない）
─────────────────────────────
1. 佐藤太郎: 03-1234-5678
2. 山田花子: 03-2345-6789
3. 鈴木一郎: 03-3456-7890
4. 田中次郎: 03-4567-8901
...
100,000. 渡辺三郎: 03-9999-9999

「山田花子」を探す場合：
→ 1ページ目から順番に全部見ていく必要がある
→ 最悪の場合、100,000ページ全部見る必要がある
→ 時間がかかる ❌
```

#### インデックスがある場合（インデックス検索）

```
電話帳（50音順に並んでいる = インデックス）
─────────────────────────────
索引（インデックス）:
あ行 → 1-10ページ
か行 → 11-20ページ
さ行 → 21-30ページ
た行 → 31-40ページ
な行 → 41-50ページ
...
や行 → 91-100ページ

「山田花子」を探す場合：
→ 「や行」の索引を見る
→ 91-100ページに絞り込む
→ その中から「山田花子」を探す
→ 高速 ✅
```

---

## データベースでのインデックス

### インデックスの作成方法

#### 1. ユニーク制約で自動的に作成される

```28:28:src/database/migrations/2025_11_27_200002_create_attendances_table.php
            $table->unique(['user_id', 'date']);
```

この 1 行で、以下が同時に作成されます：

-   **ユニーク制約**: `user_id`と`date`の組み合わせに重複を禁止するルール
-   **インデックス**: 検索を高速化するための索引（自動的に作成される）

#### 2. 明示的にインデックスを作成する場合

```php
// 単一カラムのインデックス
$table->index('date');

// 複合インデックス（複数のカラムの組み合わせ）
$table->index(['user_id', 'date']);
```

---

## インデックスの動作

### インデックスがない場合（全件スキャン）

```
attendancesテーブル（100,000件）
─────────────────────────────
id | user_id | date       | clock_in_time
─────────────────────────────────────────
1  | 1       | 2024-01-01 | 09:00:00
2  | 2       | 2024-01-01 | 09:15:00
3  | 1       | 2024-01-02 | 09:00:00
4  | 3       | 2024-01-01 | 09:30:00
...
100,000 | 50 | 2024-12-31 | 18:00:00

クエリ: WHERE date = '2024-01-15'
─────────────────────────────────
→ 1行目から順番に全部チェック
→ 100,000行全部を確認する必要がある
→ 時間がかかる ❌
```

### インデックスがある場合（インデックス検索）

```
attendancesテーブル（100,000件）
─────────────────────────────
id | user_id | date       | clock_in_time
─────────────────────────────────────────
1  | 1       | 2024-01-01 | 09:00:00
2  | 2       | 2024-01-01 | 09:15:00
3  | 1       | 2024-01-02 | 09:00:00
...
100,000 | 50 | 2024-12-31 | 18:00:00

インデックス（dateカラム用）
─────────────────────────────
date       | レコードID
─────────────────────
2024-01-01 | 1, 2, 4, ...
2024-01-02 | 3, 5, ...
2024-01-15 | 100, 200, 300, ...
...
2024-12-31 | 100,000

クエリ: WHERE date = '2024-01-15'
─────────────────────────────────
→ インデックスから「2024-01-15」を探す
→ 該当するレコードID（100, 200, 300, ...）を取得
→ そのレコードだけを読み込む
→ 高速 ✅
```

---

## このアプリでの実装

### 現在の実装

```27:28:src/database/migrations/2025_11_27_200002_create_attendances_table.php
            // この勤怠アプリは１日一つの勤怠データ制限の為user_idとdateの組み合わせでユニーク制約
            $table->unique(['user_id', 'date']);
```

この 1 行で、以下が作成されます：

1. **ユニーク制約**: `user_id`と`date`の組み合わせに重複を禁止
2. **複合インデックス**: `(user_id, date)`の組み合わせで検索を高速化

### インデックスの効果

```php
// このクエリが高速になる
$attendance = Attendance::where('user_id', 1)
    ->where('date', '2024-01-15')
    ->first();
```

**インデックスがある場合**:

-   インデックスから`user_id=1, date='2024-01-15'`を探す
-   該当するレコード ID を取得
-   そのレコードだけを読み込む
-   **処理時間**: O(log n) - 対数時間（非常に高速）

**インデックスがない場合**:

-   全レコードを順番にチェック
-   `user_id=1`かつ`date='2024-01-15'`のレコードを探す
-   **処理時間**: O(n) - 線形時間（レコード数に比例して遅くなる）

---

## インデックスの種類

### 1. 単一カラムインデックス

```php
$table->index('date');
```

-   `date`カラムだけにインデックスを張る
-   `WHERE date = '2024-01-15'`のような検索が高速化

### 2. 複合インデックス

```php
$table->unique(['user_id', 'date']);
```

-   `user_id`と`date`の組み合わせにインデックスを張る
-   `WHERE user_id = 1 AND date = '2024-01-15'`のような検索が高速化
-   順序が重要（`user_id`が先、`date`が後）

### 3. ユニークインデックス

```php
$table->unique(['user_id', 'date']);
```

-   インデックス + 重複禁止のルール
-   検索が高速化 + データ整合性を保証

---

## パフォーマンス比較

### インデックスがある場合

| レコード数   | 処理時間 | 説明                     |
| ------------ | -------- | ------------------------ |
| 1,000 件     | 1ms      | インデックス検索（高速） |
| 10,000 件    | 1ms      | インデックス検索（高速） |
| 100,000 件   | 2ms      | インデックス検索（高速） |
| 1,000,000 件 | 3ms      | インデックス検索（高速） |

**理由**: インデックスがあるため、レコード数が増えても処理時間がほとんど変わらない

### インデックスがない場合

| レコード数   | 処理時間          | 説明                                                |
| ------------ | ----------------- | --------------------------------------------------- |
| 1,000 件     | 10ms              | 全件スキャン（全レコードを確認）                    |
| 10,000 件    | 100ms             | 全件スキャン（10 倍のレコード = 10 倍の時間）       |
| 100,000 件   | 1,000ms（1 秒）   | 全件スキャン（100 倍のレコード = 100 倍の時間）     |
| 1,000,000 件 | 10,000ms（10 秒） | 全件スキャン（1,000 倍のレコード = 1,000 倍の時間） |

**理由**: インデックスがないため、全レコードを順番に確認する必要がある

---

## インデックスのデメリット

### 1. ストレージ使用量の増加

-   インデックス自体もストレージを使用する
-   ただし、検索速度の向上のメリットが大きい

### 2. 更新処理のオーバーヘッド

-   データを追加・更新・削除する際、インデックスも更新する必要がある
-   ただし、検索の頻度が高い場合は、このオーバーヘッドを上回るメリットがある

---

## まとめ

### 「カラムにインデックスを張る」とは

1. **データベースの検索を高速化する仕組み**

    - 本の索引（さくいん）のようなもの
    - 「どのデータがどこにあるか」を素早く見つける

2. **自動的に作成される場合**

    - ユニーク制約を設定すると、自動的にインデックスも作成される
    - `$table->unique(['user_id', 'date'])` → インデックスも作成される

3. **効果**
    - 検索が**10 倍～ 3,333 倍**高速化される
    - レコード数が増えても処理時間がほとんど変わらない

### このアプリでの例

```php
// マイグレーション
$table->unique(['user_id', 'date']);
```

この 1 行で：

-   ✅ ユニーク制約が作成される（重複防止）
-   ✅ インデックスが自動的に作成される（検索高速化）
-   ✅ `WHERE user_id = 1 AND date = '2024-01-15'`の検索が高速化

### 結論

**インデックスを張る = 検索を高速化するための索引を作成する**

電話帳の索引と同じように、データベースでも「どのデータがどこにあるか」を素早く見つけるための仕組みです。
