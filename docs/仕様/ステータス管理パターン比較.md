# ステータス管理パターン比較

## 概要

勤怠ステータスを管理する2つの実装パターン（`status`カラム使用 vs NULLチェック）のメリット・デメリットを比較したドキュメントです。

---

## 比較対象の2つのパターン

### パターン1: `status`カラムを使用（現在の実装）

**概要**: `attendances`テーブルに`status`カラム（integer型）を持ち、ステータス値を直接保存する方式。

**実装例**:
```php
// Attendanceモデル
public const STATUS_OFF_DUTY = 0;
public const STATUS_WORKING = 1;
public const STATUS_BREAK = 2;
public const STATUS_FINISHED = 3;

// データベース
attendances.status = 1  // STATUS_WORKING
```

**判定方法**:
```php
// シンプルな判定
if ($attendance->status === Attendance::STATUS_WORKING) {
    // 出勤中の処理
}
```

---

### パターン2: NULLチェックで判定（代替案）

**概要**: `status`カラムを持たず、`clock_in_time`、`clock_out_time`、`break_times`テーブルの状態から動的にステータスを判定する方式。

**実装例**:
```php
// Attendanceモデルに追加するメソッド
public function getStatus(): int
{
    // 1. 勤務外: clock_in_timeがNULL
    if (!$this->clock_in_time) {
        return self::STATUS_OFF_DUTY;
    }
    
    // 2. 退勤済: clock_out_timeがNULLでない
    if ($this->clock_out_time) {
        return self::STATUS_FINISHED;
    }
    
    // 3. 休憩中 vs 出勤中の判定
    // break_timesテーブルで最新の休憩レコードを確認
    $latestBreak = $this->breaks()
        ->whereNotNull('break_start_time')
        ->orderBy('break_start_time', 'desc')
        ->first();
    
    // 最新の休憩が開始されていて、終了していない場合 = 休憩中
    if ($latestBreak && $latestBreak->break_start_time && !$latestBreak->break_end_time) {
        return self::STATUS_BREAK;
    }
    
    // それ以外 = 出勤中
    return self::STATUS_WORKING;
}
```

**判定方法**:
```php
// メソッド呼び出しで判定
if ($attendance->getStatus() === Attendance::STATUS_WORKING) {
    // 出勤中の処理
}
```

---

## 詳細比較

### 1. パフォーマンス

| 項目 | パターン1: statusカラム | パターン2: NULLチェック |
|------|------------------------|------------------------|
| **単一レコードの判定** | ✅ 高速（カラム参照のみ） | ⚠️ やや遅い（メソッド実行+break_times参照） |
| **一覧表示** | ✅ 高速（インデックス検索可能） | ❌ 遅い（N+1問題が発生しやすい） |
| **クエリの複雑さ** | ✅ シンプル | ❌ 複雑（JOINやサブクエリが必要） |
| **インデックス活用** | ✅ 可能（statusカラムにインデックス） | ❌ 難しい（複数カラムの組み合わせ） |

**パターン1の例**:
```php
// シンプルで高速なクエリ
Attendance::where('status', Attendance::STATUS_WORKING)->get();
```

**パターン2の例**:
```php
// 複雑で遅いクエリ
Attendance::whereNotNull('clock_in_time')
    ->whereNull('clock_out_time')
    ->whereDoesntHave('breaks', function($q) {
        $q->whereNull('break_end_time');
    })
    ->get();
```

---

### 2. データ整合性

| 項目 | パターン1: statusカラム | パターン2: NULLチェック |
|------|------------------------|------------------------|
| **データの二重管理** | ⚠️ リスクあり（statusとclock_in_time/clock_out_timeの不整合） | ✅ リスクなし（単一の情報源） |
| **整合性チェック** | ⚠️ 必要（バリデーションやマイグレーション） | ✅ 不要（常に正しい状態を計算） |
| **データ不整合時の挙動** | ❌ 誤ったステータスが表示される可能性 | ✅ 常に正しいステータスを表示 |

**パターン1の課題例**:
```php
// データ不整合の例
// clock_out_timeがNULLなのにstatusがSTATUS_FINISHED
$attendance->clock_out_time = null;
$attendance->status = Attendance::STATUS_FINISHED;  // 不整合
```

**パターン2の利点**:
```php
// 常に正しい状態を計算
$attendance->getStatus();  // clock_out_timeがNULLならSTATUS_FINISHEDにはならない
```

---

### 3. コードの複雑さ

| 項目 | パターン1: statusカラム | パターン2: NULLチェック |
|------|------------------------|------------------------|
| **判定ロジック** | ✅ シンプル（カラム参照のみ） | ❌ 複雑（複数条件の組み合わせ） |
| **メソッドの数** | ✅ 少ない | ❌ 多い（getStatus()メソッドが必要） |
| **可読性** | ✅ 高い | ⚠️ やや低い（ロジックが分散） |
| **保守性** | ✅ 高い | ⚠️ やや低い（判定ロジックの変更が複雑） |

**パターン1の例**:
```php
// シンプルで分かりやすい
if ($attendance->status === Attendance::STATUS_WORKING) {
    // 処理
}
```

**パターン2の例**:
```php
// 複雑で理解しにくい
if ($attendance->getStatus() === Attendance::STATUS_WORKING) {
    // 処理（getStatus()の中身を理解する必要がある）
}
```

---

### 4. クエリの柔軟性

| 項目 | パターン1: statusカラム | パターン2: NULLチェック |
|------|------------------------|------------------------|
| **ステータスでのフィルタリング** | ✅ 容易（WHERE status = ?） | ❌ 困難（複雑な条件が必要） |
| **集計処理** | ✅ 容易（GROUP BY status） | ❌ 困難（計算が必要） |
| **レポート生成** | ✅ 高速 | ❌ 遅い |

**パターン1の例**:
```php
// ステータス別の集計が簡単
Attendance::selectRaw('status, COUNT(*) as count')
    ->groupBy('status')
    ->get();
```

**パターン2の例**:
```php
// ステータス別の集計が困難（全レコードを取得して計算する必要がある）
$attendances = Attendance::all();
$statusCounts = [
    'working' => 0,
    'break' => 0,
    'finished' => 0,
];
foreach ($attendances as $attendance) {
    $status = $attendance->getStatus();
    // 集計処理...
}
```

---

### 5. ストレージ効率

| 項目 | パターン1: statusカラム | パターン2: NULLチェック |
|------|------------------------|------------------------|
| **カラム数** | ⚠️ 1つ多い（statusカラム） | ✅ 少ない |
| **データサイズ** | ⚠️ やや大きい（1レコードあたり4バイト） | ✅ 小さい |
| **インデックスサイズ** | ⚠️ やや大きい | ✅ 小さい |

**データサイズの比較**:
- パターン1: `status`カラム（4バイト/レコード）
- パターン2: 追加カラムなし

**注意**: 勤怠データが大量になる場合でも、`status`カラムの4バイトは無視できる程度のサイズです。

---

### 6. 拡張性

| 項目 | パターン1: statusカラム | パターン2: NULLチェック |
|------|------------------------|------------------------|
| **新しいステータスの追加** | ✅ 容易（定数追加のみ） | ⚠️ やや困難（判定ロジックの修正が必要） |
| **ステータス遷移ルールの変更** | ✅ 容易（コントローラー修正のみ） | ❌ 困難（判定ロジック全体の見直しが必要） |
| **複雑な判定条件** | ⚠️ やや困難（バリデーションが必要） | ✅ 容易（メソッド内で自由に実装可能） |

---

### 7. デバッグ・トラブルシューティング

| 項目 | パターン1: statusカラム | パターン2: NULLチェック |
|------|------------------------|------------------------|
| **ステータスの確認** | ✅ 容易（SQLで直接確認可能） | ❌ 困難（メソッド実行が必要） |
| **データ不整合の検出** | ⚠️ やや困難（手動チェックが必要） | ✅ 容易（常に正しい状態を計算） |
| **ログ出力** | ✅ 容易（status値をそのまま出力） | ⚠️ やや困難（計算結果を出力） |

**パターン1の例**:
```sql
-- SQLで直接ステータスを確認可能
SELECT id, status, clock_in_time, clock_out_time 
FROM attendances 
WHERE user_id = 1;
```

**パターン2の例**:
```php
// メソッド実行が必要
foreach ($attendances as $attendance) {
    echo $attendance->getStatus();  // 計算が必要
}
```

---

### 8. トランザクション・整合性

| 項目 | パターン1: statusカラム | パターン2: NULLチェック |
|------|------------------------|------------------------|
| **更新処理** | ⚠️ 複数カラムの更新が必要 | ✅ 単一カラムの更新のみ |
| **トランザクション整合性** | ⚠️ やや複雑（statusとclock_in_time/clock_out_timeの同期） | ✅ シンプル（単一の情報源） |
| **ロールバック時の挙動** | ⚠️ 不整合の可能性 | ✅ 常に正しい状態 |

**パターン1の課題例**:
```php
// 出勤処理
DB::transaction(function() {
    $attendance->clock_in_time = now();
    $attendance->status = Attendance::STATUS_WORKING;
    $attendance->save();
    // もしここでエラーが発生したら、clock_in_timeだけ更新される可能性
});
```

**パターン2の利点**:
```php
// 出勤処理
DB::transaction(function() {
    $attendance->clock_in_time = now();
    $attendance->save();
    // statusは自動計算されるため、整合性が保たれる
});
```

---

## 判定フローチャート比較

### パターン1: statusカラム（現在の実装）

```
レコード取得
  ↓
statusカラムを参照
  ↓
ステータス確定
```

**処理時間**: O(1) - カラム参照のみ

---

### パターン2: NULLチェック

```
レコード取得
  ↓
clock_in_time が NULL？
  ├─ YES → STATUS_OFF_DUTY
  └─ NO
      ↓
clock_out_time が NULL？
  ├─ NO → STATUS_FINISHED
  └─ YES
      ↓
break_timesテーブルをクエリ
  ↓
最新の休憩レコードを取得
  ↓
break_end_time が NULL？
  ├─ YES → STATUS_BREAK
  └─ NO → STATUS_WORKING
```

**処理時間**: O(n) - break_timesテーブルのクエリが必要

---

## 実装例の比較

### パターン1: statusカラム（現在の実装）

```php
// AttendanceController@index()
public function index()
{
    $attendance = $this->getActiveAttendance(Auth::id());
    
    if (!$attendance) {
        $status = Attendance::STATUS_OFF_DUTY;
    } else {
        $status = $attendance->status;  // シンプル
    }
    
    return view('attendance.index', [
        'status' => $status,
    ]);
}

// 出勤処理
public function clockIn()
{
    $attendance = Attendance::create([
        'user_id' => Auth::id(),
        'date' => $today,
        'clock_in_time' => now(),
        'status' => Attendance::STATUS_WORKING,  // 明示的に設定
    ]);
}
```

---

### パターン2: NULLチェック

```php
// AttendanceController@index()
public function index()
{
    $attendance = $this->getActiveAttendance(Auth::id());
    
    if (!$attendance) {
        $status = Attendance::STATUS_OFF_DUTY;
    } else {
        $status = $attendance->getStatus();  // メソッド実行が必要
    }
    
    return view('attendance.index', [
        'status' => $status,
    ]);
}

// 出勤処理
public function clockIn()
{
    $attendance = Attendance::create([
        'user_id' => Auth::id(),
        'date' => $today,
        'clock_in_time' => now(),
        // statusカラムは不要
    ]);
    // getStatus()で自動的にSTATUS_WORKINGと判定される
}

// Attendanceモデル
public function getStatus(): int
{
    if (!$this->clock_in_time) {
        return self::STATUS_OFF_DUTY;
    }
    
    if ($this->clock_out_time) {
        return self::STATUS_FINISHED;
    }
    
    // break_timesテーブルをクエリ（パフォーマンスの問題）
    $latestBreak = $this->breaks()
        ->whereNotNull('break_start_time')
        ->orderBy('break_start_time', 'desc')
        ->first();
    
    if ($latestBreak && $latestBreak->break_start_time && !$latestBreak->break_end_time) {
        return self::STATUS_BREAK;
    }
    
    return self::STATUS_WORKING;
}
```

---

## 総合評価

### パターン1: statusカラム（現在の実装）

| 評価項目 | 評価 | 理由 |
|---------|------|------|
| **パフォーマンス** | ⭐⭐⭐⭐⭐ | インデックス検索が可能で高速 |
| **コードの簡潔性** | ⭐⭐⭐⭐⭐ | シンプルで理解しやすい |
| **データ整合性** | ⭐⭐⭐ | 二重管理のリスクがあるが、バリデーションで対応可能 |
| **拡張性** | ⭐⭐⭐⭐ | 新しいステータスの追加が容易 |
| **保守性** | ⭐⭐⭐⭐⭐ | 判定ロジックが明確 |

**総合評価**: ⭐⭐⭐⭐ (4.4/5.0)

**推奨度**: ✅ **推奨** - 勤怠管理システムではパフォーマンスとコードの簡潔性が重要

---

### パターン2: NULLチェック

| 評価項目 | 評価 | 理由 |
|---------|------|------|
| **パフォーマンス** | ⭐⭐ | break_timesテーブルのクエリが必要で遅い |
| **コードの簡潔性** | ⭐⭐ | 判定ロジックが複雑 |
| **データ整合性** | ⭐⭐⭐⭐⭐ | 常に正しい状態を計算するため整合性が高い |
| **拡張性** | ⭐⭐⭐ | 判定ロジックの修正が必要 |
| **保守性** | ⭐⭐ | 判定ロジックが分散しやすい |

**総合評価**: ⭐⭐ (2.4/5.0)

**推奨度**: ❌ **非推奨** - パフォーマンスとコードの複雑さが課題

---

## 結論

### 現在の実装（パターン1: statusカラム）を維持すべき

**理由**:

1. **パフォーマンスが重要**
   - 勤怠データは大量になる可能性がある
   - 一覧表示や集計処理で`status`カラムによるインデックス検索が有効

2. **コードの簡潔性**
   - 判定ロジックが明確で理解しやすい
   - メンテナンスが容易

3. **データ整合性のリスクは管理可能**
   - バリデーションやマイグレーションで整合性を保つことができる
   - トランザクションで更新処理の整合性を保証

4. **既存コードへの影響**
   - 現在の実装は多くの箇所で`status`カラムを参照している
   - 変更すると影響範囲が大きい

### パターン2（NULLチェック）が有効なケース

以下のような要件がある場合は、パターン2も検討の余地があります：

- ステータスが非常に複雑で、カラムで管理するのが困難
- データ整合性が最優先で、パフォーマンスは二の次
- ステータスの判定ロジックが頻繁に変更される

ただし、現在の勤怠管理システムの要件では、パターン1（statusカラム）が最適です。

---

## 参考資料

- **勤怠ステータス仕様**: `docs/仕様/勤怠ステータス.md`
- **テーブル設計**: `docs/仕様/テーブル設計案.md`
- **実装コード**: `src/app/Models/Attendance.php`, `src/app/Http/Controllers/AttendanceController.php`

