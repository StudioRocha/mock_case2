# ロール管理パターン比較

## 概要

ユーザーロールを管理する 3 つの実装パターン（クラス定数、ヘルパーメソッド、roles テーブル）のメリット・デメリットを比較したドキュメントです。

---

## 比較対象の 3 つのパターン

### パターン 1: クラス定数（現在の実装）

**概要**: `User`モデルにクラス定数としてロールを定義し、`users`テーブルの`role`カラム（integer 型）に直接値を保存する方式。

**実装例**:

```php
// Userモデル
public const ROLE_USER = 0;
public const ROLE_ADMIN = 1;

// 使用
if ($user->role === User::ROLE_ADMIN) {
    // 管理者の処理
}
```

**データベース構造**:

```sql
users テーブル
- id
- name
- email
- role (integer)  -- 0 or 1
```

---

### パターン 2: ヘルパーメソッド追加

**概要**: パターン 1 に加えて、`isAdmin()`や`isUser()`などのヘルパーメソッドを追加する方式。

**実装例**:

```php
// Userモデル
public const ROLE_USER = 0;
public const ROLE_ADMIN = 1;

public function isAdmin(): bool {
    return $this->role === self::ROLE_ADMIN;
}

public function isUser(): bool {
    return $this->role === self::ROLE_USER;
}

// 使用
if ($user->isAdmin()) {
    // 管理者の処理
}
```

**データベース構造**: パターン 1 と同じ

---

### パターン 3: roles テーブル作成（提案）

**概要**: `roles`テーブルを作成し、`users`テーブルに`role_id`（外部キー）を持たせてリレーションで管理する方式。

**実装例**:

```php
// Roleモデル
class Role extends Model {
    protected $fillable = ['name', 'label'];
}

// Userモデル
public function role() {
    return $this->belongsTo(Role::class);
}

// 使用
if ($user->role->name === 'admin') {
    // 管理者の処理
}

// または、Roleモデルにヘルパーメソッドを追加
if ($user->role->isAdmin()) {
    // 管理者の処理
}
```

**データベース構造**:

```sql
roles テーブル
- id
- name (varchar)  -- 'user', 'admin'
- label (varchar) -- '一般ユーザー', '管理者'
- created_at
- updated_at

users テーブル
- id
- name
- email
- role_id (foreign key)  -- roles.id を参照
```

---

## 詳細比較

### 1. 可読性

| 項目                     | パターン 1: クラス定数 | パターン 2: ヘルパーメソッド | パターン 3: roles テーブル |
| ------------------------ | ---------------------- | ---------------------------- | -------------------------- |
| **コードの可読性**       | ⭐⭐⭐                 | ⭐⭐⭐⭐⭐                   | ⭐⭐⭐⭐                   |
| **データベースの可読性** | ⭐⭐                   | ⭐⭐                         | ⭐⭐⭐⭐⭐                 |
| **意図の明確さ**         | ⭐⭐⭐                 | ⭐⭐⭐⭐⭐                   | ⭐⭐⭐⭐                   |

#### パターン 1 の課題

```php
// コード上
if ($user->role === User::ROLE_ADMIN) { }  // 0と比較しているように見える

// データベースで直接確認
SELECT name, role FROM users;
// 結果: 山田太郎 | 0（0が何を意味するか分からない）
```

#### パターン 2 の利点

```php
// コード上
if ($user->isAdmin()) { }  // 意図が明確
```

#### パターン 3 の利点

```php
// データベースで直接確認できる
SELECT u.name, r.label
FROM users u
JOIN roles r ON u.role_id = r.id;
// 結果: 山田太郎 | 一般ユーザー（分かりやすい）

// コード上
if ($user->role->name === 'admin') { }  // 文字列で判定（分かりやすい）
```

---

### 2. パフォーマンス

| 項目                 | パターン 1: クラス定数 | パターン 2: ヘルパーメソッド | パターン 3: roles テーブル   |
| -------------------- | ---------------------- | ---------------------------- | ---------------------------- |
| **単一レコード取得** | ⭐⭐⭐⭐⭐             | ⭐⭐⭐⭐⭐                   | ⭐⭐⭐⭐（JOIN 必要）        |
| **一覧表示**         | ⭐⭐⭐⭐⭐             | ⭐⭐⭐⭐⭐                   | ⭐⭐⭐（Eager Loading 必要） |
| **クエリの複雑さ**   | ⭐⭐⭐⭐⭐             | ⭐⭐⭐⭐⭐                   | ⭐⭐⭐                       |
| **インデックス活用** | ⭐⭐⭐⭐⭐             | ⭐⭐⭐⭐⭐                   | ⭐⭐⭐⭐                     |

#### パターン 1・2 の利点

```php
// シンプルで高速
User::all();  // そのまま使える
User::where('role', User::ROLE_ADMIN)->get();  // インデックス検索可能
```

#### パターン 3 の課題

```php
// 毎回JOINが必要
User::with('role')->get();  // Eager Loading必須（N+1問題を回避）

// ロールでフィルタリングする場合
User::whereHas('role', function($q) {
    $q->where('name', 'admin');
})->get();  // サブクエリが必要（やや遅い）
```

**注意**: 勤怠データが大量になる可能性があるため、パフォーマンスは重要です。

---

### 3. 拡張性

| 項目                 | パターン 1: クラス定数 | パターン 2: ヘルパーメソッド | パターン 3: roles テーブル |
| -------------------- | ---------------------- | ---------------------------- | -------------------------- |
| **新しいロール追加** | ⭐⭐⭐                 | ⭐⭐⭐                       | ⭐⭐⭐⭐⭐                 |
| **ロール名の変更**   | ⭐⭐                   | ⭐⭐                         | ⭐⭐⭐⭐⭐                 |
| **ロールの削除**     | ⭐⭐                   | ⭐⭐                         | ⭐⭐⭐⭐                   |
| **ロールの無効化**   | ⭐⭐                   | ⭐⭐                         | ⭐⭐⭐⭐⭐                 |

#### パターン 1・2 の課題

```php
// 新しいロール「マネージャー」を追加する場合
// 1. 定数を追加
public const ROLE_MANAGER = 2;

// 2. コードを修正（複数箇所）
if ($user->role === User::ROLE_MANAGER) { }

// 3. データベースの既存データを確認・移行
// 4. マイグレーション実行（必要に応じて）
```

#### パターン 3 の利点

```php
// コード修正なしでロール追加可能
Role::create([
    'name' => 'manager',
    'label' => 'マネージャー'
]);

// ロール名の変更も簡単
$role = Role::where('name', 'admin')->first();
$role->update(['label' => 'システム管理者']);

// ロールの無効化も可能
$role->update(['is_active' => false]);
```

---

### 4. 複雑さ

| 項目                   | パターン 1: クラス定数 | パターン 2: ヘルパーメソッド | パターン 3: roles テーブル |
| ---------------------- | ---------------------- | ---------------------------- | -------------------------- |
| **実装の複雑さ**       | ⭐⭐⭐⭐⭐             | ⭐⭐⭐⭐                     | ⭐⭐⭐                     |
| **マイグレーション**   | ⭐⭐⭐⭐⭐             | ⭐⭐⭐⭐⭐                   | ⭐⭐⭐                     |
| **既存コードへの影響** | -                      | ⭐⭐⭐⭐                     | ⭐⭐                       |
| **学習コスト**         | ⭐⭐⭐⭐⭐             | ⭐⭐⭐⭐                     | ⭐⭐⭐                     |

#### パターン 1・2 の利点

-   マイグレーション不要
-   既存コードへの影響が小さい
-   シンプルで理解しやすい

#### パターン 3 の課題

-   マイグレーションが必要
    -   `roles`テーブルの作成
    -   `users`テーブルの変更（`role`カラム → `role_id`カラム）
    -   既存データの移行
-   リレーションの設定が必要
-   既存コードの修正が必要

**マイグレーション例**:

```php
// 1. rolesテーブル作成
Schema::create('roles', function (Blueprint $table) {
    $table->id();
    $table->string('name')->unique();
    $table->string('label');
    $table->timestamps();
});

// 2. usersテーブル変更
Schema::table('users', function (Blueprint $table) {
    $table->dropColumn('role');
    $table->foreignId('role_id')->constrained('roles');
});

// 3. 既存データの移行
$userRole = Role::create(['name' => 'user', 'label' => '一般ユーザー']);
$adminRole = Role::create(['name' => 'admin', 'label' => '管理者']);

DB::table('users')->where('role', 0)->update(['role_id' => $userRole->id]);
DB::table('users')->where('role', 1)->update(['role_id' => $adminRole->id]);
```

---

### 5. 保守性

| 項目                 | パターン 1: クラス定数 | パターン 2: ヘルパーメソッド | パターン 3: roles テーブル |
| -------------------- | ---------------------- | ---------------------------- | -------------------------- |
| **コードの保守性**   | ⭐⭐⭐⭐               | ⭐⭐⭐⭐⭐                   | ⭐⭐⭐⭐                   |
| **データの保守性**   | ⭐⭐⭐                 | ⭐⭐⭐                       | ⭐⭐⭐⭐⭐                 |
| **デバッグの容易さ** | ⭐⭐⭐                 | ⭐⭐⭐⭐                     | ⭐⭐⭐⭐⭐                 |
| **テストの容易さ**   | ⭐⭐⭐⭐               | ⭐⭐⭐⭐⭐                   | ⭐⭐⭐⭐                   |

#### パターン 2 の利点

```php
// テストで簡単にモックできる
$user = Mockery::mock(User::class);
$user->shouldReceive('isAdmin')->andReturn(true);
```

#### パターン 3 の利点

```php
// データベースで直接確認できる
SELECT u.name, r.name, r.label
FROM users u
JOIN roles r ON u.role_id = r.id;

// ロール別の集計も簡単
SELECT r.label, COUNT(*) as count
FROM users u
JOIN roles r ON u.role_id = r.id
GROUP BY r.id, r.label;
```

---

### 6. セキュリティ

| 項目               | パターン 1: クラス定数 | パターン 2: ヘルパーメソッド | パターン 3: roles テーブル |
| ------------------ | ---------------------- | ---------------------------- | -------------------------- |
| **データ整合性**   | ⭐⭐⭐                 | ⭐⭐⭐                       | ⭐⭐⭐⭐⭐                 |
| **外部キー制約**   | ❌ なし                | ❌ なし                      | ✅ あり                    |
| **不正な値の防止** | ⚠️ バリデーション必要  | ⚠️ バリデーション必要        | ✅ 外部キーで保証          |

#### パターン 3 の利点

```php
// 外部キー制約により、存在しないロールIDを設定できない
$user->role_id = 999;  // エラー: 外部キー制約違反

// パターン1・2では
$user->role = 999;  // エラーにならない（バリデーション必要）
```

---

### 7. ストレージ効率

| 項目                       | パターン 1: クラス定数 | パターン 2: ヘルパーメソッド | パターン 3: roles テーブル |
| -------------------------- | ---------------------- | ---------------------------- | -------------------------- |
| **users テーブルのサイズ** | ⭐⭐⭐⭐⭐             | ⭐⭐⭐⭐⭐                   | ⭐⭐⭐⭐                   |
| **追加テーブル**           | ❌ なし                | ❌ なし                      | ✅ roles テーブル          |
| **JOIN のオーバーヘッド**  | ❌ なし                | ❌ なし                      | ⚠️ あり                    |

**データサイズの比較**:

-   パターン 1・2: `role`カラム（4 バイト/レコード）
-   パターン 3: `role_id`カラム（8 バイト/レコード）+ roles テーブル

**注意**: ユーザー数が少ない場合は無視できる程度の差ですが、大量のユーザーがいる場合は考慮が必要です。

---

## 実装例の比較

### パターン 1: クラス定数（現在の実装）

```php
// Userモデル
class User extends Authenticatable {
    public const ROLE_USER = 0;
    public const ROLE_ADMIN = 1;
}

// コントローラー
public function list() {
    if (Auth::user()->role === User::ROLE_ADMIN) {
        // 管理者の処理
    } else {
        // 一般ユーザーの処理
    }
}

// ビュー
@if(Auth::user()->role === \App\Models\User::ROLE_ADMIN)
    <a href="{{ route('admin.dashboard') }}">管理画面</a>
@endif
```

---

### パターン 2: ヘルパーメソッド追加

```php
// Userモデル
class User extends Authenticatable {
    public const ROLE_USER = 0;
    public const ROLE_ADMIN = 1;

    public function isAdmin(): bool {
        return $this->role === self::ROLE_ADMIN;
    }

    public function isUser(): bool {
        return $this->role === self::ROLE_USER;
    }
}

// コントローラー
public function list() {
    if (Auth::user()->isAdmin()) {
        // 管理者の処理
    } else {
        // 一般ユーザーの処理
    }
}

// ビュー
@if(Auth::user()->isAdmin())
    <a href="{{ route('admin.dashboard') }}">管理画面</a>
@endif
```

---

### パターン 3: roles テーブル

```php
// Roleモデル
class Role extends Model {
    protected $fillable = ['name', 'label'];

    public function isAdmin(): bool {
        return $this->name === 'admin';
    }
}

// Userモデル
class User extends Authenticatable {
    public function role() {
        return $this->belongsTo(Role::class);
    }

    public function isAdmin(): bool {
        return $this->role->name === 'admin';
    }
}

// コントローラー
public function list() {
    $users = User::with('role')->get();  // Eager Loading必須

    if (Auth::user()->isAdmin()) {
        // 管理者の処理
    } else {
        // 一般ユーザーの処理
    }
}

// ビュー
@if(Auth::user()->isAdmin())
    <a href="{{ route('admin.dashboard') }}">管理画面</a>
@endif
```

---

## 現在のアプリケーションでの判断

### 結論: 現時点では**パターン 2（クラス定数 + ヘルパーメソッド）**が最適

**理由**:

1. **ロールが 2 種類のみ（User, Admin）**

    - テーブル化のメリットが小さい
    - クラス定数で十分管理できる

2. **ロールが固定**

    - 頻繁に追加・変更しない
    - コードで管理しても問題ない

3. **パフォーマンスが重要**

    - 勤怠データが大量になる可能性
    - JOIN を避けられる

4. **実装の簡潔さ**

    - マイグレーション不要
    - 既存コードへの影響が小さい

5. **可読性の向上**
    - ヘルパーメソッドで意図が明確になる

---

### パターン 3（roles テーブル）が有効なケース

以下の要件がある場合は、パターン 3 の検討を推奨します：

-   **ロールが 5 種類以上になる可能性**

    -   例: User, Admin, Manager, Supervisor, HR など

-   **ロールを動的に追加・変更したい**

    -   管理画面でロールを管理したい
    -   コード修正なしでロールを追加したい

-   **ロールごとに権限（permissions）を細かく管理したい**

    -   例: 「勤怠閲覧」「勤怠編集」「申請承認」などの細かい権限

-   **ロールの履歴管理が必要**

    -   ロールの変更履歴を記録したい

-   **ロールの無効化が必要**
    -   一時的にロールを無効化したい

---

## 推奨実装（現時点）

### パターン 2: クラス定数 + ヘルパーメソッド

```php
// Userモデル
class User extends Authenticatable {
    /**
     * ユーザーロールの定数
     */
    public const ROLE_USER = 0;
    public const ROLE_ADMIN = 1;

    /**
     * 管理者かどうかを判定
     *
     * @return bool
     */
    public function isAdmin(): bool {
        return $this->role === self::ROLE_ADMIN;
    }

    /**
     * 一般ユーザーかどうかを判定
     *
     * @return bool
     */
    public function isUser(): bool {
        return $this->role === self::ROLE_USER;
    }
}
```

**使用例**:

```php
// コントローラー
if (Auth::user()->isAdmin()) {
    // 管理者の処理
}

// ビュー
@if(Auth::user()->isAdmin())
    <a href="{{ route('admin.dashboard') }}">管理画面</a>
@endif
```

**メリット**:

-   ✅ 可読性が高い（`isAdmin()`で意図が明確）
-   ✅ パフォーマンスが良い（JOIN 不要）
-   ✅ 実装が簡単（マイグレーション不要）
-   ✅ 既存コードへの影響が小さい

---

## 将来の移行計画

将来的にロールが増える可能性がある場合は、以下のタイミングでパターン 3（roles テーブル）への移行を検討：

### 移行のタイミング

1. **ロールが 3 種類以上になった時**
2. **ロールを動的に管理する必要が出た時**
3. **権限管理が複雑になった時**

### 移行時の注意点

1. **既存データの移行**

    - `role`カラム（0, 1）を`role_id`に変換
    - roles テーブルに初期データを投入

2. **既存コードの修正**

    - `$user->role` → `$user->role_id` または `$user->role->name`
    - `User::ROLE_ADMIN` → `Role::where('name', 'admin')->first()`

3. **パフォーマンスへの影響**
    - Eager Loading の追加が必要
    - クエリの最適化が必要

---

## 総合評価

### パターン 1: クラス定数

| 評価項目           | 評価       | 理由                                      |
| ------------------ | ---------- | ----------------------------------------- |
| **可読性**         | ⭐⭐⭐     | コード上は分かりやすいが、DB 上は数値のみ |
| **パフォーマンス** | ⭐⭐⭐⭐⭐ | JOIN 不要で高速                           |
| **拡張性**         | ⭐⭐⭐     | ロール追加時にコード修正が必要            |
| **実装の簡潔さ**   | ⭐⭐⭐⭐⭐ | シンプルで理解しやすい                    |
| **保守性**         | ⭐⭐⭐⭐   | コードの保守は容易                        |

**総合評価**: ⭐⭐⭐⭐ (4.0/5.0)

---

### パターン 2: ヘルパーメソッド

| 評価項目           | 評価       | 理由                                 |
| ------------------ | ---------- | ------------------------------------ |
| **可読性**         | ⭐⭐⭐⭐⭐ | `isAdmin()`で意図が明確              |
| **パフォーマンス** | ⭐⭐⭐⭐⭐ | JOIN 不要で高速                      |
| **拡張性**         | ⭐⭐⭐     | ロール追加時にコード修正が必要       |
| **実装の簡潔さ**   | ⭐⭐⭐⭐   | シンプルで理解しやすい               |
| **保守性**         | ⭐⭐⭐⭐⭐ | コードの保守が容易、テストもしやすい |

**総合評価**: ⭐⭐⭐⭐⭐ (4.6/5.0) **推奨**

---

### パターン 3: roles テーブル

| 評価項目           | 評価       | 理由                                     |
| ------------------ | ---------- | ---------------------------------------- |
| **可読性**         | ⭐⭐⭐⭐   | DB 上でも分かりやすい                    |
| **パフォーマンス** | ⭐⭐⭐     | JOIN が必要でやや遅い                    |
| **拡張性**         | ⭐⭐⭐⭐⭐ | ロール追加が容易                         |
| **実装の簡潔さ**   | ⭐⭐⭐     | マイグレーションとリレーション設定が必要 |
| **保守性**         | ⭐⭐⭐⭐   | データの保守が容易                       |

**総合評価**: ⭐⭐⭐⭐ (3.8/5.0)

**推奨度**: ロールが 5 種類以上になる場合に検討

---

## 結論

### 現在のアプリケーションでは**パターン 2（クラス定数 + ヘルパーメソッド）**を推奨

**理由**:

1. ロールが 2 種類のみで、固定されている
2. パフォーマンスが重要（勤怠データが大量になる可能性）
3. 実装が簡単で、既存コードへの影響が小さい
4. 可読性が高い（`isAdmin()`で意図が明確）

### 将来的な移行

ロールが増える可能性がある場合は、その時点でパターン 3（roles テーブル）への移行を検討することを推奨します。

---

## 参考資料

-   **ユーザーロール仕様**: `docs/仕様/ユーザーロール仕様.md`
-   **テーブル設計**: `docs/仕様/テーブル設計案.md`
-   **実装コード**: `src/app/Models/User.php`
